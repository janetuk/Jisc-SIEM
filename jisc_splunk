#!/bin/bash
# Do not edit this file directly. It is composed from smaller chunks and any changes will be lost on the next build

JISC_SCRIPT_VERSION='1.0.14'
JISC_SCRIPT_VERSION_HASH='f98c2089c7'

# begin src/prefix
show_help() {
  echo "A script to simplify routine maintence of Jisc configured splunk infrastructure."
  echo "The script is intended to be agnostic for the splunk type installed (Heavy or Universal forwarder) so the same commands should have the same"
  echo "effect on either type. The script is also agnostic of linux flavour and systemd or initd."
  echo
  echo "examples:"
  echo "installing an app"
  echo "    sudo ./jisc_splunk --app jisc_inputs --cmd install"
  echo
  echo "Installing a deployment app. This will put the app in deployment-apps and add the app to the given server class. The deployment server will then be reloaded"
  echo "    sudo ./jisc_splunk --serverclass int_forwarders --app jisc_inputs --cmd install"
  echo
  echo "Splunk operations:"
  echo "These commands are to operate on the currently installed/running instance of splunk"
  echo "e.g jisc_splunk --splunk start"
  echo "--splunk {cmd}[,{cmd}]"
  echo
  echo "start                        Start splunk if it isn't ready running"
  echo "restart                      Restarts splunk if splunk is currently running. But it splunk is currently not running then does nothing"
  echo "stop                         Stops splunk if it is currently running"
  echo "version                      Shows the version of splunk currently installed"
  echo "permissions                  Sets/updates the file permissions on      SPLUNK_HOME"
  echo "tail                         Runs a tail command on splunkd.log"
  echo "status                       Outputs splunk status"
  echo "migrate_kv_store             Migrates an old style kv store to splunk's new flavour"
  echo "enable_boot_start            Enables splunk boot start."
  echo "disable_boot_start           Disables splunk boot start"
  echo "disable_deployment_server    Disables this machine as a deployment server"
  echo "enable_deployment_server     Enables this machine as a deployment server"
  echo "python_enable_https_verify   Turns on https verify in splunk-launch.conf"
  echo
  echo "The --cmd options:"
  echo "--cmd {cmd}[,{cmd}]"
  echo "These are broader brush commands to upgrade splunk or other multistep operations"
  echo
  echo "Script administration options:"
  echo "--push {username@host}     Pushes this script via scp to the home directory of username on machine host."
  echo "--pull                     Pull the latest version of this script from the public github site"
  echo "--su                       Switch to the defined splunk user"
}

# Go from 8.0.7 to version 8.2.6
# ./jisc_splunk --target 8.2.6 --cmd upgrade
# ./jisc_splunk --cmd deploy
#
# Go from 8.2.6 to 9.0.0
# ./jisc_splunk --target 9.0.0 --cmd upgrade
# ./jisc_splunk --cmd deploy
#
# Copy of new version is created in /opt/jisc_splunk/splunk|splunkforwarder
#
# Then use
#    ./jisc_splunk --cmd deploy
#
# This will
#  * move /opt/splunk to inside /opt/jisc_splunk with a date/time added to name
#  * copy over /opt/jisc_splunk/splunk|splunkforwarder
#  * set splunk boot start and start up splunk
#
# You can also daisy chain commands. e.g. to install and deploy
#   ./jisc_splunk --cmd install,deploy
#
# The script will look for a jisc.config file which can hold settings.
# e.g.
# SPLUNK_TYPE=hf
# SPLUNK_USER=root
# SPLUNK_GROUP=root
# DISABLE_BACKUPS=1
#
# This is handy if system has different set up.

# More safety, by turning some bugs into errors.
# Without `errexit` you don’t need ! and can replace
# ${PIPESTATUS[0]} with a simple $?, but I prefer safety.
set -o errexit -o pipefail -o noclobber -o nounset

# -allow a command to fail with !’s side effect on errexit
# -use return value from ${PIPESTATUS[0]}, because ! hosed $?
! getopt --test >/dev/null
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
  echo 'I’m sorry, `getopt --test` failed in this environment.'
  exit 1
fi

# Logging functions. Need these up top so we can use them during setup.

log_write() {
  local level=$1
  local line=$2
  local msg=$3
  local log_file=${4:-}
  local timestamp=$(date +"%FT%T.%3N")
  local m=$(printf "%s [%s] [%s] %s" $timestamp $level $line "$msg")

  echo "$m"
  if [[ ! -z "$log_file" ]]; then
    echo "$m" >>$log_file
  fi
}

log_verbose() {
  if [[ "$verbose" == "1" ]]; then
    log_file=${2:-}
    log_write "DEBUG" $BASH_LINENO "$1" $log_file
  fi
}

log_info() {
  log_file=${2:-}
  log_write "INFO" $BASH_LINENO "$1" $log_file
}

log_warn() {
  log_file=${2:-}
  log_write "WARN" $BASH_LINENO "$1" $log_file
}

log_error() {
  log_file=${2:-}
  log_write "ERROR" $BASH_LINENO "$1" $log_file
}

# If this file exists then we'll load any vars in there
JISC_CONFIG="jisc.config"

# Log for info from this script
JISC_LOG="/var/log/jisc.log"

# set everything up out of the way of /opt/splunk
WORKING_DIR="/opt/jisc_splunk"

SPLUNK_TYPE_UF="uf"
SPLUNK_TYPE_HF="hf"
SPLUNK_TYPE_DS="ds"

PUBLIC_SRC="https://raw.githubusercontent.com/janetuk/Jisc-SIEM/main/jisc_splunk"

# option --output/-o requires 1 argument
LONGOPTS=su,help,force,type:,quiet,pull,push:,cmd:,splunk:,target:,serverclass:,app:,message:
OPTIONS=hft:qcbp:c:s:sc:a:m:

# -regarding ! and PIPESTATUS see above
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
  # e.g. return value is 1
  #  then getopt has complained about wrong arguments to stdout
  exit 2
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# These'll get set either via values in $JISC_CONFIG or by command line args
# The currently installed flavour of splunk
SPLUNK_TYPE=
# The target flavour of splunk we are after. This would only be needed to install.
SPLUNK_TARGET_TYPE=
# The user/group to run splunk as. If empty then defaults to splunk:splunk
SPLUNK_USER=""
SPLUNK_GROUP=""
SPLUNK_TARGET_VERSION="9.0.0"
SPLUNK_ARGS="--no-prompt --accept-license --answer-yes"
PRETEND_CURRENT_VERSION=""
IS_DEPLOYMENT_SERVER_ENABLED="-"
IS_SYSTEMD="-"
DISABLE_BACKUPS=0
SPLUNK_EXE=
SPLUNK_SERVER_CLASS=
SPLUNK_APP=
JISC_MESSAGE=

help=0
force=0
verbose=1
pull=
push=
cmd=""
su=
splunk_cmd=""

if [[ -f $JISC_CONFIG ]]; then
  log_info "loading settings from $JISC_CONFIG"
  source $JISC_CONFIG
fi

#
# parse any command line args
#

# now enjoy the options in order and nicely split until we see --
while true; do
  case "$1" in
  -h | --help)
    help=1
    shift
    ;;
  -f | --force)
    force=1
    shift
    ;;
  -q | --quiet)
    verbose=0
    shift
    ;;
  -t | --type)
    SPLUNK_TARGET_TYPE="$2"
    shift 2
    ;;
  --su)
    su=1
    shift
    ;;
  --message | -m)
    JISC_MESSAGE="$2"
    shift 2
    ;;
  --target)
    SPLUNK_TARGET_VERSION="$2"
    shift 2
    ;;
  --app | -a)
    SPLUNK_APP="$2"
    shift 2
    ;;
  --serverclass | -su)
    SPLUNK_SERVER_CLASS="$2"
    shift 2
    ;;
  --pull)
    pull=1
    shift 1
    break
    ;;
  -p | --push)
    push="$2"
    shift 2
    break
    ;;
  -s | --splunk)
    splunk_cmd="$2"
    shift 2
    break
    ;;

  -c | --cmd)
    cmd="$2"
    shift 2
    break
    ;;
  --)
    shift
    break
    ;;
  *)
    echo "unknown command line argument '$1'"
    exit 3
    ;;
  esac
done

# handle non-option arguments
#if [[ $# -ne 1 ]]; then
#    echo "$0: A single input file is required."
#    exit 4
#fi

command_exists() {
  local cli="$1"
  regex="$cli:(.*)"
  where=$(whereis $cli)
  result=0
  if [[ $where =~ $regex ]]; then
    result=$([[ -z "${BASH_REMATCH[1]}" ]] && echo 0 || echo 1)
  fi
  echo $result
}

ensure_working_dir_exists() {
  if [ ! -d "$WORKING_DIR" ]; then
    mkdir -p $WORKING_DIR
    chown -R $SPLUNK_USER:$SPLUNK_GROUP $WORKING_DIR >/dev/null
    log_verbose "file permissions in $SPLUNK_HOME set to $SPLUNK_USER:$SPLUNK_GROUP"
  fi
}

check_if_systemd() {
  local error_code=0
  systemctl >/dev/null 2>&1 || error_code=$?
  if [[ "${error_code}" -eq 0 ]]; then
    IS_SYSTEMD=1
  else
    IS_SYSTEMD=0
  fi
}

download_splunk() {
  local dest=""
  local src=""

  [[ -z "$SPLUNK_TARGET_TYPE" ]] && log_error "SPLUNK_TARGET_TYPE should be defined to allow for downloading" && exit 3

  local splunk_version_8_2_6_hash="a6fe1ee8894b"
  local splunk_version_9_0_0_hash="6818ac46f2ec"

  case "$SPLUNK_TARGET_VERSION" in
  "8.2.6")
    splunk_hash=$splunk_version_8_2_6_hash
    ;;
  "9.0.0")
    splunk_hash=$splunk_version_9_0_0_hash
    ;;
  esac

  case "$SPLUNK_TARGET_TYPE" in
  $SPLUNK_TYPE_UF)
    splunk_product="universalforwarder"
    splunk_download_prefix="splunkforwarder"
    ;;
  $SPLUNK_TYPE_HF | $SPLUNK_TYPE_DS)
    splunk_product="splunk"
    splunk_download_prefix="splunk"
    ;;
  *)
    log_warn "don't know how to download splunk type '$SPLUNK_TARGET_TYPE'"
    exit 3
    ;;
  esac

  if [[ -z "$SPLUNK_HOME" ]]; then
    set_splunk_env $splunk_download_prefix
  fi

  src="https://download.splunk.com/products/$splunk_product/releases/${SPLUNK_TARGET_VERSION}/linux/$splunk_download_prefix-$SPLUNK_TARGET_VERSION-$splunk_hash-Linux-x86_64.tgz"
  dest="$WORKING_DIR/$splunk_download_prefix-$SPLUNK_TARGET_VERSION-$splunk_hash-Linux-x86_64.tgz"

  if test -f "$dest"; then
    log_verbose "$dest already downloaded"
  else
    log_verbose "downloading to $dest"
    ensure_working_dir_exists
    log_verbose "download from $src"
    wget -O $dest $src
  fi

  SPLUNK_TAR_TGZ=$dest
  # 8.1
  #wget -O $WORKING_DIR/splunk-8.1.0-f57c09e87251-Linux-x86_64.tgz "https://download.splunk.com/products/splunk/releases/8.1.0/linux/splunk-8.1.0-f57c09e87251-Linux-x86_64.tgz"
}

create_working_copy() {
  if [[ $DISABLE_BACKUPS == 0 ]]; then
    if ! test -d "$SPLUNK_HOME"; then
      log_verbose "splunk not currently installed. nothing to do"
    else
      splunk_status
      log_verbose "need to stop splunk to take a copy"
      splunk_stop
      log_verbose "copying from $SPLUNK_HOME into $SPLUNK_WORKING_HOME"
      copy_files $SPLUNK_HOME $WORKING_DIR
      if [[ $IS_SPLUNK_RUNNING == 1 ]]; then
        log_verbose "starting splunk back up since it was running before"
        splunk_start
      fi
    fi
  fi
}

create_backup() {
  if [[ $DISABLE_BACKUPS == 0 ]]; then
    if [[ -d $SPLUNK_HOME ]]; then
      timestamp=$(date +"%FT%T.%3N")
      dest="$WORKING_DIR/splunk_$timestamp"
      copy_files $SPLUNK_HOME $dest
      log_info "$SPLUNK_HOME backed up into $dest"
    else
      log_verbose "splunk not installed at $SPLUNK_HOME. Nothing to backup"
    fi
  else
    log_warn "backups have been disabled via DISABLE_BACKUPS. Not going to backup"
  fi
}

get_public_ip() {
  # get the public/external ip address of this machine
  wget -qO- https://ipecho.net/plain
  echo
}

unzip_download() {
  log_info "unziping splunk package '$SPLUNK_TAR_TGZ' into working location '$SPLUNK_WORKING_HOME'."
  tar --checkpoint=.1000 -xf $SPLUNK_TAR_TGZ -C $WORKING_DIR
  # The progress dots from the tar will leave the cursor midline.
  # get onto a new line
  echo ""
}

copy_files() {

  log_verbose "[$BASH_LINENO] copying from $1"
  [ -v "$2" ] && echo "cannot copy_files from '$1' - to parameter not defined" && exit 3

  local from_dir=$1
  local to=$2

  # redhat 8.6 minimal doesn't have rsync
  if [[ $(command_exists "rsync") == "1" ]]; then
    # Use rsync if we have it so users seens some progression
    local rsync_args="-ah --info=progress2"
    rsync $rsync_args $from_dir $to
  else
    # if we can't rsync then just use cp. Won't get nice info while this is happening through
    cp -r $from_dir $to
  fi
}

# We're not just splatting on top of existing splunk to make sure
# we get a clean version free of any lof4j files
copy_existing_confs_apps() {

  if test -d "$SPLUNK_HOME"; then
    splunk_set_file_permissions
    log_verbose "copying relevent configs/apps from $SPLUNK_HOME into $SPLUNK_WORKING_HOME"
    [[ -d $SPLUNK_HOME/etc/system/local ]] && copy_files $SPLUNK_HOME/etc/system/local/* $SPLUNK_WORKING_HOME/etc/system/local && log_verbose "copied local"
    # We want everything that's in the deployment-apps
    [[ -d $SPLUNK_HOME/etc/deployment-apps ]] && copy_files $SPLUNK_HOME/etc/deployment-apps $SPLUNK_WORKING_HOME/etc && log_verbose "copied deployment-apps"
    [[ -d $SPLUNK_HOME/etc/system/local ]] && copy_files $SPLUNK_HOME/etc/system/local $SPLUNK_WORKING_HOME/etc/system && log_verbose "copied system local"
    [[ -d $SPLUNK_HOME/etc/auth ]] && copy_files $SPLUNK_HOME/etc/auth $SPLUNK_WORKING_HOME/etc && log_verbose "copied auth"
    [[ -d $SPLUNK_HOME/etc/apps/Splunk_TA_nix ]] && copy_files $SPLUNK_HOME/etc/apps/Splunk_TA_nix $SPLUNK_WORKING_HOME/etc/apps && log_verbose "copied Splunk_TA_nix"
    [[ -f $SPLUNK_HOME/etc/instance.cfg ]] && copy_files $SPLUNK_HOME/etc/instance.cfg $SPLUNK_WORKING_HOME/etc && log_verbose "copied instance.cfg"
    [[ -f $SPLUNK_HOME/etc/passwd ]] && copy_files $SPLUNK_HOME/etc/passwd $SPLUNK_WORKING_HOME/etc && log_verbose "copied passwd"
    [[ -f $SPLUNK_HOME/etc/auth/splunk.secret ]] && copy_files $SPLUNK_HOME/etc/auth/splunk.secret $SPLUNK_WORKING_HOME/etc/auth && log_verbose "copied splunk.secret"

    # We'll keep any app which starts with numbers (e.g. 1234_*) will be copied across.
    find $SPLUNK_HOME/etc/apps -maxdepth 1 -type d | grep -P '/\d+_.*$' | xargs -n1 -I '{}' sudo cp -r '{}' $SPLUNK_WORKING_HOME/etc/apps
  else
    # No splunk installed. Nothing to copy.
    echo ""
  fi

  if test -d "$SPLUNK_WORKING_HOME"; then
    splunk_set_file_permissions

    log_verbose "created dir for the new version of splunk $SPLUNK_WORKING_HOME"
  else
    log_warn "failed to build the expected dir $SPLUNK_WORKING_HOME"
    exit 1
  fi

}

splunk_set_file_permissions() {
  if test -d "$SPLUNK_HOME"; then
    chown -R $SPLUNK_USER:$SPLUNK_GROUP $SPLUNK_HOME
    #log_verbose "file permissions in $SPLUNK_HOME set to $SPLUNK_USER:$SPLUNK_GROUP"
  fi

  if test -d "$SPLUNK_WORKING_HOME"; then
    chown -R $SPLUNK_USER:$SPLUNK_GROUP $SPLUNK_WORKING_HOME
    #log_verbose "file permissions in $SPLUNK_HOME set to $SPLUNK_USER:$SPLUNK_GROUP"
  fi
}

splunk_status() {
  if [[ -f $SPLUNK_EXE ]]; then
    error_code=0
    $SPLUNK_EXE status >/dev/null || error_code=$?
    if [[ "${error_code}" -eq 0 ]]; then
      IS_SPLUNK_RUNNING=1
    else
      IS_SPLUNK_RUNNING=0
    fi
  else
    IS_SPLUNK_RUNNING="-1"
    log_verbose "splunk not installed in $SPLUNK_HOME"
  fi
}

# Stop splunk and turn off boot start
# https://docs.splunk.com/Documentation/Splunk/8.2.6/Admin/RunSplunkassystemdservice
splunk_stop() {
  if [[ -d $SPLUNK_HOME ]]; then
    splunk_status
    if [[ $IS_SPLUNK_RUNNING == 1 ]]; then
      log_verbose "stopping splunk"
      $SPLUNK_EXE stop $SPLUNK_ARGS
    else
      log_verbose "splunk already stopped"
    fi
  fi
}

splunk_start() {
  if [[ -d $SPLUNK_HOME ]]; then
    splunk_status
    if [[ $IS_SPLUNK_RUNNING == 0 ]]; then
      splunk_set_file_permissions
      log_verbose "starting splunk"
      $SPLUNK_EXE start $SPLUNK_ARGS
    else
      log_verbose "splunk already running"
    fi
  fi
}

splunk_restart() {
  if [[ -d $SPLUNK_HOME ]]; then
    splunk_status
    if [[ $IS_SPLUNK_RUNNING == 1 ]]; then
      splunk_set_file_permissions
      log_verbose "restarting splunk..."
      if [[ $IS_SYSTEMD == 1 ]]; then
        local service_name=
        case "$SPLUNK_TYPE" in
        $SPLUNK_TYPE_UF)
          service_name="SplunkForwarder"
          ;;
        $SPLUNK_TYPE_HF | $SPLUNK_TYPE_DS)
          service_name="Splunkd"
          ;;
        *)
          log_warn "don't knos systemd service name for  splunk type '$SPLUNK_TYPE'"
          exit 3
          ;;
        esac
        systemctl restart $service_name
      else
        $SPLUNK_EXE restart $SPLUNK_ARGS
      fi
    else
      log_verbose "splunk is not currently running. no need to restart"
    fi
  fi
}

splunk_process_start_time() {
  local start_time="$(ps -eo cmd,lstart)"
  local regex='splunkd -p \S+ start\s+(\S+\s\S+\s\S+\s\S+\s\S{4})'

  if [[ $start_time =~ $regex ]]; then
    result=${BASH_REMATCH[1]}
    epoch_time=$(date -d "$result" +%s)
    now=$(date +%s)
    delta=$((now - epoch_time))
    uptime=$(date -ud "@$delta" +'%Hh %Mm %Ss')
    log_info "splunk has been running for $uptime"
  fi
}

splunk_enable_boot_start() {
  if [[ -d $SPLUNK_HOME ]]; then
    splunk_set_file_permissions
    # this might be the first run of splunk.
    splunk_stop
    splunk_set_file_permissions
    if [[ $IS_SYSTEMD == 1 ]]; then
      log_verbose "setting up splunk for boot start under systemd"
      $SPLUNK_EXE enable boot-start $SPLUNK_ARGS -systemd-managed 1 -user $SPLUNK_USER -group $SPLUNK_GROUP
    else
      log_verbose "setting up splunk for boot start under initd"
      $SPLUNK_EXE enable boot-start $SPLUNK_ARGS -systemd-managed 0 -user $SPLUNK_USER -group $SPLUNK_GROUP
      # Put the SPLUNK_USER su statements into the init.d file (that splunk recommend, and do in the systemd version but not in the init.d for some reason)
      sed -i -r -e "s|^(\s+)(\"$SPLUNK_EXE\")|\1su - $SPLUNK_USER -c \2|g" /etc/init.d/splunk
    fi
    splunk_set_file_permissions
  fi
}

splunk_disable_boot_start() {
  if [[ -f $SPLUNK_EXE ]]; then
    if [[ $IS_SYSTEMD == 1 ]]; then
      log_verbose "disabling bootstart on systemd"
      $SPLUNK_EXE disable boot-start $SPLUNK_ARGS
    else
      $SPLUNK_EXE disable boot-start $SPLUNK_ARGS
    fi
  fi
}

search_replace() {
  local file=$1
  local regex=$2
  if [[ -f $file ]]; then
    local contents=$(cat $SPLUNK_FILE_SPLUNK_LAUNCH_CONF)
    if [[ $contents =~ $regex ]]; then
      result=${BASH_REMATCH[1]}
      echo $result
    else
      echo "-"
    fi
  else
    log_error "file '$file' not found. can't search it"
    exit 3
  fi
}

splunk_python_disable_https_verify() (
  local regex="PYTHONHTTPSVERIFY\s*=\s*(\w+)"

  local x=$(search_replace $SPLUNK_FILE_SPLUNK_LAUNCH_CONF $regex)

  case "$x" in
  "" | "-") ;;

  "true" | "1")
    sed -i ':a;N;$!ba;s/PYTHONHTTPSVERIFY=1/PYTHONHTTPSVERIFY=0/g' $SPLUNK_FILE_SPLUNK_LAUNCH_CONF
    splunk_restart
    ;;
  "false" | "0") ;;

  *)
    log_error "don't know how to handle '$x'"
    exit 1
    ;;
  esac
)

splunk_python_enable_https_verify() (
  local regex="PYTHONHTTPSVERIFY\s*=\s*(\w+)"

  local x=$(search_replace $SPLUNK_FILE_SPLUNK_LAUNCH_CONF $regex)
  case "$x" in
  "" | "-")
    printf "\nPYTHONHTTPSVERIFY=1\n" >>$SPLUNK_FILE_SPLUNK_LAUNCH_CONF
    splunk_restart
    ;;
  "true" | "1")
    # its already 1 nothing to do
    ;;
  "false" | "0")
    # switch PYTHONHTTPSVERIFY=0 to PYTHONHTTPSVERIFY=1 if its in the file
    sed -i ':a;N;$!ba;s/PYTHONHTTPSVERIFY=0/PYTHONHTTPSVERIFY=1/g' $SPLUNK_FILE_SPLUNK_LAUNCH_CONF
    splunk_restart
    ;;
  *)
    log_error "don't know how to handle '$x'"
    exit 1
    ;;
  esac
)

# For endpoint forwarders not on splunk 9. This will make the endpoint bind to localhost
# and not accept any cli commands.
splunk_bindip_localhost() (
  local regex="SPLUNK_BINDIP\s*=\s*(\S+)"

  local x=$(search_replace $SPLUNK_FILE_SPLUNK_LAUNCH_CONF $regex)
  echo $x
  case "$x" in
  "-")
    printf "\nSPLUNK_BINDIP=127.0.0.1\n" >>$SPLUNK_FILE_SPLUNK_LAUNCH_CONF
    splunk_restart
    ;;
  "127.0.0.1")
    # its already set nothing to do
    ;;
  "*")
    sed -i ':a;N;$!ba;s/$regex/127.0.0.1/g' $SPLUNK_FILE_SPLUNK_LAUNCH_CONF
    splunk_restart
    ;;
  esac
)

splunk_remove_bindip() {
  sed -i ':a;N;$!ba;s/SPLUNK_BINDIP=127.0.0.1//g' $SPLUNK_FILE_SPLUNK_LAUNCH_CONF
  splunk_restart
}

update_splunk_launch() {
  ensure_splunk_env
  [[ ! -f $SPLUNK_FILE_SPLUNK_LAUNCH_CONF ]] && log_error "expecting file $SPLUNK_FILE_SPLUNK_LAUNCH_CONF to exist" && exit 3
  log_verbose "enabling python https verify"
  splunk_python_enable_https_verify

  # Not for jisc machines that need the to talk to other computers on the management port
  #log_verbose "explicitly setting bindip to localhost"
  #splunk_bindip_localhost
  splunk_remove_bindip
}

deploy_splunk() {
  ensure_splunk_env
  [[ -z "$SPLUNK_WORKING_HOME" ]] && log_error "\$SPLUNK_WORKING_HOME not set. Noting to deploy" && exit 3
  if [[ -d $SPLUNK_HOME ]]; then
    timestamp=$(date +"%FT%T.%3N")
    dest="$WORKING_DIR/splunk_$timestamp"
    log_verbose "moving the $SPLUNK_HOME to $dest"
    splunk_disable_boot_start
    mv $SPLUNK_HOME $dest
    #log_verbose "deleting $SPLUNK_HOME directory (remember we have a copy)"
    #rm -fr $dest
  fi
  log_verbose "copying working folder '$SPLUNK_WORKING_HOME' to '$SPLUNK_HOME'"
  copy_files "$SPLUNK_WORKING_HOME" "/opt"
  [[ ! -d $SPLUNK_HOME ]] && log_error "SPLUNK_HOME ('$SPLUNK_HOME') directory expected but not found" && exit 3
  log_verbose "finished setting up working folder '$SPLUNK_WORKING_HOME' to '$SPLUNK_HOME'"
}

splunk_version() {
  # So we can force the version while testing things
  if [[ ! -z $PRETEND_CURRENT_VERSION ]]; then
    SPLUNK_CURRENT_VERSION=$PRETEND_CURRENT_VERSION
  else
    if [[ -f $SPLUNK_EXE ]]; then
      local v=$($SPLUNK_EXE version $SPLUNK_ARGS)
      local regex=".*([0-9]+\.[0-9]+\.[0-9]+)"
      if [[ $v =~ $regex ]]; then
        SPLUNK_CURRENT_VERSION=${BASH_REMATCH[1]}
      else
        echo "couldn't parse the version number out of '$v'"
        SPLUNK_CURRENT_VERSION="<none>"
      fi
      #SPLUNK_CURRENT_VERSION=$($SPLUNK_EXE version $SPLUNK_ARGS | grep -Eo '[0-9]+\.[0-9]+\.[0-9]')
    else
      SPLUNK_CURRENT_VERSION="<none>"
    fi
  fi
}

# This will take the directory we have created with the new setup and
# copy it over to SPLUNK_HOME
deploy_package() {
  log_verbose "deploying setup from $SPLUNK_WORKING_HOME to $SPLUNK_HOME"
  splunk_stop
  deploy_splunk
  splunk_enable_boot_start
  # on a fresh install splunk-launch.conf won't yet exist
  # the splunk enable boot above will create the file.
  # so can only update after the boot start command
  update_splunk_launch
  splunk_start
  log_verbose "$SPLUNK_HOME setup with new version and splunk is starting. ./jisc_splunk --splunk status to check"
}

clean() {
  rm -fr $WORKING_DIR
}

# Make it a little easier to get this script onto another machine.
# The push parameter will need to be a user@host
push_script() {
  log_info "copying script to $push"
  scp jisc_splunk $push:~/jisc_splunk
}

migrate_kv_store() {
  # Since we're putting a new version in place could just stick the WireTiger setting into server.conf
  # into the new version at the start instead of migrating?
  if [ "$SPLUNK_TYPE" == $SPLUNK_TYPE_UF ]; then
    log_warn "Universal forwarder does not make use of kv store. no need to migrate"
  else
    log_verbose "Start migrating kv store"
    log_verbose "stopping splunk"
    $SPLUNK_EXE $SPLUNK_ARGS stop
    echo -e "\n[kvstore]\nstorageEngineMigration=true" >>$SPLUNK_HOME/etc/system/local/server.conf
    log_verbose "starting kv store migration. see $SPLUNK_HOME/var/log/splunk/mongod.log"
    $SPLUNK_EXE $SPLUNK_ARGS migrate kvstore-storage-engine --target-engine wiredTiger
    log_verbose "starting splunk..."
    $SPLUNK_EXE $SPLUNK_ARGS start
  fi
}

tail_splunkd_log() {
  tail -f -n 256 $SPLUNK_HOME/var/log/splunk/splunkd.log
}

confirm() {
  local question=$1
  CONFIRM=0
  read -t 30 -n 1 -p $question answer
  echo ""
  if [ "$answer" == "y" ]; then
    CONFIRM=1
  else
    CONFIRM=0
  fi
}

upgrade_to_826() {
  SPLUNK_TARGET_VERSION="8.2.6"
  download_splunk $SPLUNK_TARGET_TYPE $SPLUNK_TARGET_VERSION

  if test -d "$SPLUNK_WORKING_HOME"; then
    log_verbose "deleting existing working folder $SPLUNK_WORKING_HOME"
    rm -fr $SPLUNK_WORKING_HOME
  fi

  splunk_stop
  splunk_disable_deployment_server
  unzip_download
  copy_existing_confs_apps
}

upgrade_to_900() {
  SPLUNK_TARGET_VERSION="9.0.0"
  download_splunk $SPLUNK_TARGET_TYPE $SPLUNK_TARGET_VERSION
  create_working_copy
  # unpack everything on top
  unzip_download
  splunk_set_file_permissions
}

setup_splunk_env() {

  set_splunk_env ""

  if test -d "/opt/splunk"; then
    SPLUNK_TYPE=$SPLUNK_TYPE_HF
    set_splunk_env "splunk"
  fi
  if test -d "/opt/splunkforwarder"; then
    SPLUNK_TYPE=$SPLUNK_TYPE_UF
    set_splunk_env "splunkforwarder"
  fi

  if [[ ! -z "$SPLUNK_HOME" ]]; then
    if [[ -f "$SPLUNK_FILE_SERVERCLASS_CONF" ]]; then
      # splunk 9 has an empty serverclass.conf in place.
      # we'll assume if it is not zero size then machine is a deployment server
      local file_size=$(du "$SPLUNK_FILE_SERVERCLASS_CONF" | cut -f1)

      if [[ $file_size > 0 ]]; then
        SPLUNK_TYPE=$SPLUNK_TYPE_DS
      fi
    fi

    SPLUNK_EXE="$SPLUNK_HOME/bin/splunk"
  fi
}

set_splunk_env() {
  local dir_name=$1

  if [[ -z dir_name ]]; then
    SPLUNK_HOME=
    SPLUNK_WORKING_HOME=
    SPLUNK_EXE=
    SPLUNK_FILE_SERVERCLASS_CONF=
    SPLUNK_FILE_SPLUNK_LAUNCH_CONF=
  else
    SPLUNK_HOME="/opt/$dir_name"
    SPLUNK_WORKING_HOME="$WORKING_DIR/$dir_name"
    SPLUNK_EXE="$SPLUNK_HOME/bin/splunk"
    SPLUNK_FILE_SERVERCLASS_CONF="$SPLUNK_HOME/etc/system/local/serverclass.conf"
    SPLUNK_FILE_SPLUNK_LAUNCH_CONF="$SPLUNK_HOME/etc/splunk-launch.conf"
  fi
}

ensure_splunk_env() {

  if [[ -z "$SPLUNK_HOME" ]]; then
    case "$SPLUNK_TARGET_TYPE" in
    $SPLUNK_TYPE_UF)
      splunk_product="universalforwarder"
      splunk_download_prefix="splunkforwarder"
      ;;
    $SPLUNK_TYPE_HF | $SPLUNK_TYPE_DS)
      splunk_product="splunk"
      splunk_download_prefix="splunk"
      ;;
    *)
      log_warn "don't know how to download splunk type '$SPLUNK_TARGET_TYPE'"
      exit 3
      ;;
    esac

    set_splunk_env $splunk_download_prefix
  fi
}

system_info() {
  # Try to keep the output splunk log friendly
  # Aim for key value pairs
  local info=""
  info+="$(date +"%FT%T.%3N") [INFO]"
  info+=" JOID='$JOID'"
  info+=" JISC_SCRIPT_VERSION='$JISC_SCRIPT_VERSION'"
  info+=" JISC_SCRIPT_VERSION_HASH='$JISC_SCRIPT_VERSION_HASH'"
  info+=" SPLUNK_TYPE='$SPLUNK_TYPE'"
  info+=" hostname='$(hostname)'"
  info+=" local_ip='$(hostname -I | sed 's/\s//g')'"
  info+=" external_ip='$(get_public_ip)'"
  info+=" storage_dir='/opt' storage='$(df -h --output=used,avail,pcent /opt | sed 1d)'"

  info+=" kernal='$(uname -r)'"
  if [[ $(command_exists "lsb_release") == "1" ]]; then
    info+=" lsb_release='$(lsb_release --id --release --codename --description --short | sed -z 's/\n/,/g')'"
  fi

  # this is key/value already
  info+=" "
  info+="$(cat /etc/os-release | sed s/\"/\'/g)"
  if [[ $(command_exists "firewall-cmd") == "1" ]]; then
    info+=" firewalld_ports='$(firewall-cmd --list-ports)'"
  else
    info+=" firewalld_ports='' firewalld_msg='firewalld not installed'"
  fi
  if [[ $(command_exists "ufw") == "1" ]]; then
    info+=" ufw_status='$(ufw status verbose)'"
  fi
  #echo "firewalld not installed. listing iptables:"
  #iptables -L

  # Send the info to the jisc log
  [[ -f $JISC_LOG ]] && echo $info >>$JISC_LOG

  # show in console
  echo $info
}

get_joid() {
  JOID=
  local test_dir=$SPLUNK_HOME/etc/apps/
  if [[ -d $test_dir ]]; then
    local ls=$(find $test_dir -mindepth 1 -maxdepth 1 -type d -printf '%f\n')
    local regex="\s*([0-9]+)_int_forwarder_outputs|([0-9]+)_member_forwarder_outputs_nix"
    if [[ $ls =~ $regex ]]; then
      if [[ ! -z "${BASH_REMATCH[1]}" ]]; then
        JOID=${BASH_REMATCH[1]}
      else
        JOID=${BASH_REMATCH[2]}
      fi
    fi
  fi
}

# end src/prefix

# begin src/deployment_server
splunk_disable_deployment_server() {
  if [[ $SPLUNK_TYPE == $SPLUNK_TYPE_DS ]]; then
    local tmp_file="$WORKING_DIR/tmp.conf"

    splunk_is_deployment_server_enabled
    if [[ "$IS_DEPLOYMENT_SERVER_ENABLED" == "1" ]]; then
      if [[ -f $SPLUNK_FILE_SERVERCLASS_CONF ]]; then
        ensure_working_dir_exists
        # Let's take a backup
        cp $SPLUNK_FILE_SERVERCLASS_CONF $WORKING_DIR
        (printf "[global]\ndisabled = true\n" && cat $SPLUNK_FILE_SERVERCLASS_CONF) >$tmp_file && mv $tmp_file $SPLUNK_FILE_SERVERCLASS_CONF
        splunk_is_deployment_server_enabled
      else
        log_warn "no serverclass.conf file found at $SPLUNK_FILE_SERVERCLASS_CONF"
      fi
    else
      log_info "deployment server is already disabled."
    fi
  else
    log_warn "this machine is not operating as deployment server. SPLUNK_TYPE='$SPLUNK_TYPE'"
  fi
}

splunk_enable_deployment_server() {
  if [[ $SPLUNK_TYPE == $SPLUNK_TYPE_DS ]]; then
    if [[ -f $SPLUNK_FILE_SERVERCLASS_CONF ]]; then
      sed -i ':a;N;$!ba;s/\[global\]\s\+disabled\s*=\s*true\s\+//g' $SPLUNK_FILE_SERVERCLASS_CONF
      splunk_restart
    else
      log_warn "no serverclass.conf file found at $SPLUNK_FILE_SERVERCLASS_CONF"
    fi
    splunk_is_deployment_server_enabled
  else
    log_warn "this machine is not operating as deployment server. SPLUNK_TYPE='$SPLUNK_TYPE'"
  fi
}

# This will work only if the serverclass.conf if setup in a known way.
# But since we own this file we are okay in this case.
splunk_is_deployment_server_enabled() {
  local result
  local regex='\[global\]\s+disabled\s*=\s*(\w+)'

  IS_DEPLOYMENT_SERVER_ENABLED=

  if [[ $SPLUNK_TYPE == $SPLUNK_TYPE_DS ]]; then
    if [[ -f $SPLUNK_FILE_SERVERCLASS_CONF ]]; then
      local contents=$(cat $SPLUNK_FILE_SERVERCLASS_CONF)
      if [[ $contents =~ $regex ]]; then
        result=${BASH_REMATCH[1]}
        case "$result" in
        "" | "false")
          IS_DEPLOYMENT_SERVER_ENABLED=1
          ;;
        "true")
          IS_DEPLOYMENT_SERVER_ENABLED=0
          ;;
        *)
          log_error "don't know how to handle '$result'"
          exit 1
          ;;
        esac
      else
        IS_DEPLOYMENT_SERVER_ENABLED=1
      fi
    fi
  fi
}

extract_bundle() {
  local dest_dir="$WORKING_DIR/bundle"
  local dest_tgz="$WORKING_DIR/bundle.tgz"

  ensure_working_dir_exists

  if [[ ! -f $dest_tgz ]]; then
    #find last line +1
    SCRIPT_END=$(awk '
          BEGIN { err=1; } 
          /^\w*___END_OF_SHELL_SCRIPT___\w*$/ { print NR+1; err=0; exit 0; } 
          END { if (err==1) print "?"; }
        ' "$0")

    # check for error
    if [ "$SCRIPT_END" == '?' ]; then
      echo Can\'t find embedded bundle file
      exit 1
    fi
    # Extract file
    tail -n +$SCRIPT_END $0 | base64 -d >$dest_tgz

  fi

  if [[ ! -d $dest_dir ]]; then
    tar xf $dest_tgz -C $WORKING_DIR
    find $dest_dir -type d -exec chmod 755 {} \;
    find $dest_dir -type f -exec chmod 644 {} \;
  fi
}

install_app() {
  local src_dir_list=$1
  local dest_dir=$2
  local app_name=$3
  local dest_name="${JOID}_$app_name"

  extract_bundle

  local installed=
  for src_dir in ${src_dir_list//;/ }; do
    local src="$src_dir/JOID_$app_name"
    if [[ -d $src ]]; then
      local dest_tmp_dir="$WORKING_DIR/$dest_name"
      [[ -d $dest_tmp_dir ]] && rm -fr $dest_tmp_dir
      cp -r $src $dest_tmp_dir
      find $dest_tmp_dir -type f -exec sed -i 's/JOID/'$JOID'/g' {} +
      mkdir -p $dest_dir
      [[ -d "$dest_dir/$dest_name" ]] && rm -fr "$dest_dir/$dest_name"
      mv $dest_tmp_dir $dest_dir
      splunk_set_file_permissions
      log_info "app created in '$dest_dir/$dest_name' from source at '$src'"
      installed="1"
    fi
  done

  if [[ -z $installed ]]; then
    log_error "could not find an app $app_name to install"
  fi
}

install_local_app() {
  local app_name=$1

  install_app "$WORKING_DIR/bundle/apps;$WORKING_DIR/bundle/deployment-apps" "$SPLUNK_HOME/etc/apps" $app_name
}

add_to_serverclass() {
  local class_name=$1
  local app_name=$2
  local dest_class_name="${JOID}_$class_name"
  local dest_app_name="${JOID}_$app_name"

  ensure_working_dir_exists
  cp $SPLUNK_FILE_SERVERCLASS_CONF "$WORKING_DIR/serverclass.conf"

  # we are looking for something like this
  # [serverClass:129_int_forwarders:app:129_int_forwarder_inputs]

  regex="\[serverClass:$dest_class_name:app:$dest_app_name\]"

  local content=$(cat $SPLUNK_FILE_SERVERCLASS_CONF)
  if [[ $content =~ $regex ]]; then
    # app is already defined in the server class
    log_info "app $dest_app_name is already a member of serverclass $dest_class_name"
  else
    # its not already there. Appended it to serverclass.conf
    printf '\n[serverClass:%s:app:%s]\nrestartSplunkWeb = 0\nrestartSplunkd = 1\nstateOnClient = enabled\n' $dest_class_name $dest_app_name >>$SPLUNK_FILE_SERVERCLASS_CONF
    log_info "app $dest_app_name has been added to serverclass $dest_class_name"
  fi
}

install_deployment_app() {
  local server_classname=$1
  local app_name=$2

  install_app "$WORKING_DIR/bundle/deployment-apps" "$SPLUNK_HOME/etc/deployment-apps" $app_name
  add_to_serverclass $server_classname $app_name
  deployment_server_reload
}

create_member_forwarder_serverclass() {
  #[serverClass:129_member_forwarders]
  #whitelist.0 = *
  local class_name="member_forwarders"
  local allow_list="*"

  local dest_class_name="${JOID}_$class_name"

  ensure_working_dir_exists
  cp $SPLUNK_FILE_SERVERCLASS_CONF "$WORKING_DIR/serverclass.conf"

  regex="\[serverClass:$dest_class_name\]"

  local content=$(cat $SPLUNK_FILE_SERVERCLASS_CONF)
  if [[ $content =~ $regex ]]; then
    # app is already defined in the server class
    log_info "server class '$dest_class_name' already exists"
  else
    # its not already there. Appended it to serverclass.conf
    printf '\n[serverClass:%s]\n' "$dest_class_name" >>$SPLUNK_FILE_SERVERCLASS_CONF
    printf 'whitelist.0 = %s\n' "$allow_list" >>$SPLUNK_FILE_SERVERCLASS_CONF
    log_info "server class '$class_name' has been added to serverclass.conf"
  fi

  add_to_serverclass $class_name "disable_management"
}

deployment_server_list_serverclasses() {
  # looking for things like [serverClass:Splunk_TA_Windows]
  local server_classes=
  readarray server_classes < <(sed -nr "s/^\[serverClass\:([^\:]*)\]/\1/p" $SPLUNK_FILE_SERVERCLASS_CONF)
  server_classes=($(for l in ${server_classes[@]}; do echo $l; done | sort))

  local count=${#server_classes[@]}
  printf "serverClasses found count=%s\n" $count
  local i=1
  for class in "${server_classes[@]}"; do
    #for i in ${server_classes// / }; do
    printf "serverClass[%i/%s]: %s\n" $i $count $class
    i=$((i + 1))
  done

}

deployment_server_reload() {
  if [[ $SPLUNK_TARGET_TYPE == $SPLUNK_TYPE_DS && $IS_SPLUNK_RUNNING == "1" ]]; then
    runuser -s /bin/bash -l $SPLUNK_USER -c "$SPLUNK_EXE reload deploy-server"
  fi
}

# end src/deployment_server

# begin src/splunk_commands
splunk_commands() {

  if [[ ! -z $splunk_cmd ]]; then

    for i in ${splunk_cmd//,/ }; do
      #log_verbose "running splunk cmd '$i'"
      case "$i" in
      "start")
        splunk_start
        ;;

      "restart")
        splunk_restart
        ;;

      "stop")
        splunk_stop
        ;;

      "version")
        splunk_version
        log_verbose "SPLUNK_CURRENT_VERSION=$SPLUNK_CURRENT_VERSION"
        ;;

      "permissions")
        splunk_set_file_permissions
        ;;

      "tail")
        tail_splunkd_log
        ;;

      "status")
        splunk_status
        log_info "splunk running status $IS_SPLUNK_RUNNING"
        ;;

      "reload")
        deployment_server_reload
        ;;

      "migrate_kv_store")
        migrate_kv_store $SPLUNK_HOME
        ;;

      "enable_boot_start")
        splunk_enable_boot_start
        ;;

      "disable_boot_start")
        splunk_disable_boot_start
        splunk_start
        ;;

      "disable_deployment_server")
        splunk_disable_deployment_server
        [[ ! -z "$IS_DEPLOYMENT_SERVER_ENABLED" ]] && log_info "IS_DEPLOYMENT_SERVER_ENABLED: $IS_DEPLOYMENT_SERVER_ENABLED"
        ;;

      "enable_deployment_server")
        splunk_enable_deployment_server
        [[ ! -z "$IS_DEPLOYMENT_SERVER_ENABLED" ]] && log_info "IS_DEPLOYMENT_SERVER_ENABLED: $IS_DEPLOYMENT_SERVER_ENABLED"
        ;;

      "python_enable_https_verify")
        splunk_python_enable_https_verify
        ;;

      "update_splunk_launch")
        update_splunk_launch
        ;;

      *)
        log_warn "don't know splunkcmd '$splunk_cmd'"
        exit 3
        ;;
      esac
    done
    log_verbose "done"
    exit 0
  fi
}

# end src/splunk_commands

# begin src/jisc_commands
jisc_commands() {
  if [[ ! -z $cmd ]]; then

    for i in ${cmd//,/ }; do
      case "$i" in
      "info")
        system_info
        ;;

      "backup")
        create_backup
        ;;

      "download")
        download_splunk
        ;;

      "install")
        if [[ ! -z $SPLUNK_APP ]]; then
          if [[ ! -z $SPLUNK_SERVER_CLASS ]]; then
            install_deployment_app $SPLUNK_SERVER_CLASS $SPLUNK_APP
          else
            install_local_app $SPLUNK_APP
          fi
        else
          if [[ -z "$SPLUNK_HOME" ]]; then
            download_splunk
            unzip_download
            copy_existing_confs_apps
            create_backup
            log_verbose "run --cmd deploy to put the working package into place and start splunk"
          else
            log_error "splunk is already installed in $SPLUNK_HOME. Perhaps your mean to do --upgrade rather than --install?"
          fi
        fi
        ;;

      "install_apps")
        # A server class for all member fowarders and an app to disable managemnent
        create_member_forwarder_serverclass
        # Pick up info in /var/log/jisc.log on jisc machines
        install_local_app "int_jisc_inputs"
        # Same app being set to other machines
        install_deployment_app "int_forwarders" "int_jisc_inputs"
        install_deployment_app "member_forwarders" "forwarder_disable_management"
        ;;

      "uninstall")
        splunk_stop
        splunk_disable_boot_start
        rm -fr $SPLUNK_HOME
        set_splunk_env ""
        ;;

      "unzip")
        download_splunk
        unzip_download
        ;;

      "copy_conf")
        copy_existing_confs_apps
        ;;

      "upgrade")
        log_verbose "current splunk version is $SPLUNK_CURRENT_VERSION"
        case "$SPLUNK_CURRENT_VERSION" in
        "$SPLUNK_TARGET_VERSION")
          log_verbose "already at version $SPLUNK_TARGET_VERSION. nothing to do"
          ;;
        "9.0.0")
          log_verbose "already at highest version. nothing to do"
          ;;
        "8.0.7")
          log_verbose "upgrading from 8.0.7 ==> $SPLUNK_TARGET_VERSION"
          upgrade_to_826
          ;;
        "8.2.6")
          # we can do a normal splunk update on this
          # upzip on top of existing splunk
          log_verbose "upgrading from 8.2.6 to $SPLUNK_TARGET_VERSION"
          upgrade_to_900
          ;;
        *)
          log_error "don't know how to upgrade from $SPLUNK_CURRENT_VERSION"
          exit 3
          ;;
        esac
        ;;

      "deploy")
        deploy_package
        ;;

      "clean")
        clean
        ;;
      *)
        log_warn "don't know cmd '$cmd'"
        exit 3
        ;;
      esac
    done
    exit 0
  fi
}

# end src/jisc_commands

# begin src/main
pull_latest() {
  wget $PUBLIC_SRC
}

switch_user() {
  su $SPLUNK_USER --shell /bin/bash
}

write_message() {
  log_info "JOID='$JOID' message='$1'" $JISC_LOG
}

#############################################################################
#
# The real start of the script

if [[ $help == 1 ]]; then
  show_help
  exit 0
fi

if [[ ! -z $push ]]; then
  push_script
  exit 0
fi

if [[ ! -z $pull ]]; then
  pull_latest
  exit 0
fi

log_verbose "starting.."

[[ ! -f $JISC_LOG ]] && touch $JISC_LOG

setup_splunk_env
splunk_version
splunk_status
check_if_systemd
splunk_is_deployment_server_enabled

SPLUNK_TAR_TGZ=""

get_joid

if [[ ! -z $JISC_MESSAGE ]]; then
  write_message "$JISC_MESSAGE"
  exit 0
fi

# if SPLUNK_TARGET_TYPE not explicitly set, use the currently installed type
[[ -z "$SPLUNK_TARGET_TYPE" ]] && SPLUNK_TARGET_TYPE=$SPLUNK_TYPE
# default user and group if not explicitly set
[[ -z "$SPLUNK_USER" ]] && SPLUNK_USER=splunk
[[ -z "$SPLUNK_GROUP" ]] && SPLUNK_GROUP=splunk

if [[ ! -z $su ]]; then
  switch_user
  exit 0
fi

log_info "JISC_SCRIPT_VERSION: $JISC_SCRIPT_VERSION"
log_info "JISC_SCRIPT_VERSION_HASH: $JISC_SCRIPT_VERSION_HASH"
log_info "JISC_LOG: $JISC_LOG"
log_info "JOID: $JOID"
log_info "WORKING_DIR: $WORKING_DIR"
log_info "SPLUNK_CURRENT_VERSION: $SPLUNK_CURRENT_VERSION"
log_info "SPLUNK_TYPE: $SPLUNK_TYPE"
log_info "SPLUNK_TARGET_TYPE: $SPLUNK_TARGET_TYPE"
log_info "SPLUNK_TARGET_VERSION: $SPLUNK_TARGET_VERSION"
log_info "SPLUNK_HOME: $SPLUNK_HOME"
log_info "SPLUNK_USER: $SPLUNK_USER"
log_info "SPLUNK_GROUP: $SPLUNK_GROUP"
log_info "SPLUNK_WORKING_HOME: $SPLUNK_WORKING_HOME"
log_info "IS_SYSTEMD: $IS_SYSTEMD"
[[ ! -z $IS_DEPLOYMENT_SERVER_ENABLED ]] && log_info "IS_DEPLOYMENT_SERVER_ENABLED: $IS_DEPLOYMENT_SERVER_ENABLED"
log_info "---"

[[ $DISABLE_BACKUPS == 1 ]] && log_warn "the creation backups has been disabled."

#
# All the variables are setup now.
#

case "$IS_SPLUNK_RUNNING" in
"1")
  log_info "splunk *is* currently running"
  splunk_process_start_time
  ;;
"0")
  log_info "splunk is currently *not* running"
  ;;
"-1")
  log_info "splunk is not installed"
  ;;
esac

if [[ $SPLUNK_TYPE == $SPLUNK_TYPE_DS ]]; then
  if [[ "$IS_SPLUNK_RUNNING" != "-1" && "$SPLUNK_CURRENT_VERSION" != "9.0.0" ]]; then
    if [[ "$IS_DEPLOYMENT_SERVER_ENABLED" == "1" ]]; then
      log_warn "deployment server is enabled and not running splunk 9.0.0. Disabling the deployment server"
      splunk_disable_deployment_server
      # if splunk is currently running then restart, else leave it stopped
      splunk_restart
    fi
  fi
fi

splunk_commands

jisc_commands

exit 0

# end src/main
___END_OF_SHELL_SCRIPT___
H4sIAAAAAAAAA+2aa2/bNhSG81m/gkCBXQJE90tSwCiKJMM6xMnQJB2GIBBoirYZS6QnUnbcX79D
OZcmReuoXRW0Ow8C60JKMvme95CiM2pkUXJv61viA1mW2W2QJf6H21u2gjhMgyRKQz/a8oMggg1J
vum3uqHRhtaEbBW85rPP1NtU/p0yWutP53P9zYKgk/5RCPqHIRSj/j1wo3/B56VaVVyanf8+FJ6q
f+j7UZSmoH8chzHq3wef0P+PkzcH+VjVS1pDw/NCaDoqeV5RSSfcVusSIU/XP/TjKNnywwjqo/59
8MX6l4rR8mlR0F3/OMgC1L8PvlJ/zesFr12m5PjTz9ikf+Snj/RPIzv++310wP9c/4sJl7ym5aVD
y1It3/JKGX6kJkKSAZEcxHWci6kx89NW6UvnBTmbCk34eMyZEQterohpaqmJGo+JmXKy6+/ukbmq
DfkFAogIOW/Mr+1lnFSUTYXkZCnKkmhjP2sO54hqDFFyfa1R7X3uQ5Kso8y5icIDPqZNaf60jxgQ
Uzfcee5e/H75Sv8v+WiD+bc2+z+Eyd5D/ydpkKL/++BCc2OEnGjr7L/AdUr+bMD4vGhNCPquzUfq
Rkqo59juMvenB8SHCys64239+wBZpwAlIT/QBRWljR/SBk25cqpJZX5X+tbD7ekpHL+0CQDd3CNf
7P+3h68PhoduVWx+xgb/B3722P9xlEbo/z7Yn1IJg/2kdS9ljGt9OwA/8rLrtAM//Nlh/fy31tsu
cRw7sAtpeF3xQlDDyV3caDKlC04Yr40YCwZlcHNaztrnrR9Sw4QDqqyziXYdx8419EvPWy6Xrp6X
jZzBAFN5XOaN9ua1KhpmdjRnTS3MyqNSqkay9ltqTy+KHQiicMdP/cSdmqp8lU/KQbAdqIb9E9Lt
fEK3h1fD1fCMBccHb5Kjq8Pg5GAYHV/N3g/Pzl2oIIrt4dnk/cnZ68Buj1fx9fHVeQT7cMXf73+C
WwxCN02CKA6T2A12oz0/gc/MDdIkC3aTOI12wiiECI/DPTdIoCjdi4LkrmWFYvrDph0o1tjvT41Q
0jttC7w913d97/S2nYfS+u/s6HQf+tJmTkkr/o6WomiverEPY7CYNDXPoU5uU2lua+SLuyrWzTn0
eL5+QL5/9Oa+s9mCu5UwNXdVPfHYROyMhLRn7U1cOH5ldwb77w7X/QvNS1LM0z8An8v/YOr8SmiW
t3P4L18U7P7+Dxt8/++FLvp3WPJ5QHf9gyTE3396obv+UL75le8Bm/QPkuTx+i8MLzj/64MLIaED
yvLSvtjB3G1AeDvVKBznYk7ZDGaAlw6bcjZrJxDNvGhncQMypqXmUKkRl47Q+UJoYd/wbgvg1Hr+
SD84+9yNRT6iu//XB11SwEb/h9lj/2dBhv7vg4tKSWFUDS8B3oLWoPHEs5q7sHN5u+JatMs8Qhb8
Gvba2NCK5UpLcZ1rUzhaNTXjZjW3VreXP3ezkCfSxf8VNxTSP+06BXz6/3+EWZSG4H8A53+90EX/
Dkt+D9iY/+PH+T/IggTzfx+ca7sY91Hqt8tzNWeqLohmtZgbwq85a+xCEqGyIMpMuf1tD+aEVbu8
RMyUGsKoJCNObsYUGDdGq3Y4cJ+7mQiCIAiCIAiCIAiCIAiCIAiCIAiCIAiCIAiCIAjyQ/Evd9pJ
uABQAAA=
